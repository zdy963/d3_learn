<!DOCTYPE html>
<meta charset="utf-8">
<title>Force-Directed Graph</title>
<style>

    .node {
        cursor: pointer;
        stroke: #3182bd;
        stroke-width: 1.5px;
    }

    .link {
        fill: none;
        stroke: #9ecae1;
        stroke-width: 1.5px;
    }

    .node_text {
        font-size: 12px;
        font-family: SimSun;
        fill: white;
        font-weight: 800;
    }

    .link_text {
        font-size: 12px;
        font-family: SimSun;
        font-weight: 900;
        fill: black;
    }

    .selected{
        -webkit-transition:border linear .2s,-webkit-box-shadow linear .5s;
        border-color:rgba(141,39,142,.75);
        -webkit-box-shadow:0 0 18px rgba(111,1,32,3);
    }

</style>
<body>
<script src="//d3js.org/d3.v3.min.js"></script>
<script src="//code.jquery.com/jquery-3.3.1.slim.min.js"></script>
<script>

    $(document).on("click",function (d) {
        if(d.target.nodeName == "svg"){
            $(".node, .link, .node_text, .link_text")
                .attr("opacity",1)
                .removeClass("selected");
        }
    });

    var width = 960,
        height = 800,
        root;

    var force = d3.layout.force()
        .size([width, height])
        .on("tick", tick);

    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);

    var link = svg.selectAll(".link"),
        node = svg.selectAll(".node"),
        node_text = svg.selectAll(".node_text"),
        link_text = svg.selectAll(".link_text");

    d3.json("test.json", function(error, json) {
        if (error) throw error;
        root = json;

        update();
    });

    function update() {
        var nodes = root.nodes,
            links = root.links;

        links = linkcount(links);
        console.log(links);
        // links = calcTranslationApproximate(links);
        // console.log(document.getElementById("g1").getBBox());

        // 启动force layout
        force
            .nodes(nodes)
            .links(links)
            .linkDistance(200)
            .charge(-1500)
            .start();

        // 自定义拖拽函数
        var node_drag = d3.behavior.drag()
            .on("dragstart", dragstart)
            .on("drag", dragmove)
            .on("dragend", dragend);

        function dragstart(d, i) {
            force.stop() // stops the force auto positioning before you start dragging
        }
        function dragmove(d, i) {
            d.px += d3.event.dx;
            d.py += d3.event.dy;
            d.x += d3.event.dx;
            d.y += d3.event.dy;
            tick(); // this is the key to make it work together with updating both px,py,x,y on d !
        }
        function dragend(d, i) {
            d.fixed = true; // of course set the node to fixed so the force doesn't include the node in its auto positioning stuff
            tick();
            // force.resume();
        }


        // 链
        link = link.data(links);
        link.exit().remove();
        link.enter()
        //     .insert("line", ".node")
        //     .attr("class", "link")
        //     .attr("x1", function(d) {
        //         // console.log(d.source.x);
        //         return d.source.x; })     // x-cor of source point
        //     .attr("y1", function(d) { return d.source.y; })     // y-cor of source point
        //     .attr("x2", function(d) { return d.target.x; })
        //     .attr("y2", function(d) { return d.target.y; })
        //     .attr("pointer-events", "none");
            .append("path")
            .attr("class", "link")
            .attr("marker-end",function(d,i){
                var arrowMarker = svg.append("marker")
                    .attr("id","arrow"+i)
                    .attr("markerUnits","userSpaceOnUse")
                    .attr("markerWidth","16")
                    .attr("markerHeight","15")
                    .attr("viewBox","0 0 12 12")
                    .attr("refX",9)
                    .attr("refY",6)
                    .attr("orient","auto")
                    .append("svg:path")
                    .attr("d","M2,2 L10,6 L2,10 L6,6 L2,2")
                    .attr("fill",function(){
                        return d.lineColor = "" ? lineColor:d.lineColor;
                    });

                return "url(#arrow" + i + ")";
            });


        // 结点
        node = node.data(nodes, function(d) { return d.id }).style("fill", color);
        node.exit().remove();
        node.enter()
            .append("circle")
            .attr("class", "node")
            // .attr("class", "rect")
            .attr("cx", function(d) { return d.x; })    // cx define the x-axis of a center point
            .attr("cy", function(d) { return d.y; })    // cy define the y-axis ..
            .attr("r", function(d) { return Math.sqrt(d.size) || 45; })   // define the radius
            .style("fill", color)
            .on("click", click)
            .call(node_drag);


        // 在链上写结点间的关系
        link_text = link_text.data(links);
        link_text.exit().remove();
        link_text.enter()
            .append("text")
            .attr("class", "link_text")
            .attr("text-anchor", "middle")
            .attr("pointer-events", "none")
            .text(function (d) {
                return d.relationship;
            });


        // 在结点上写名字
        node_text = node_text.data(nodes);
        node_text.exit().remove();
        node_text.enter()
            .append("text")
            .attr("class", "node_text")
            .attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; })
            .attr("text-anchor", "middle")  // 使文本在元素上居中而非左对齐
            .attr("dominant-baseline", "middle")
            .attr("pointer-events", "none")
            .text(function (d) {
                return d.name;
            });
    }

    // 使结点位置可动的关键代码
    function tick() {
        // console.log(link);
        // link.attr("x1", function(d) { return d.source.x; })
        //     .attr("y1", function(d) { return d.source.y; })
        //     .attr("x2", function(d) { return d.target.x; })
        //     .attr("y2", function(d) { return d.target.y; });
        link.attr("d", function(d) {
            let x0 = d.source.x,
                y0 = d.source.y,
                x1 = d.target.x,
                y1 = d.target.y,
                x1_x0 = x1 - x0,
                y1_y0 = y1 - y0,
                x2_x0, y2_y0,
                distance = 12;
            // console.log(link);
            if (y1_y0 === 0 || Math.abs(x1_x0 / y1_y0) > 1) {
                y2_y0 = -distance;
                x2_x0 = distance * y1_y0 / x1_x0;
            } else {
                x2_x0 = distance;
                y2_y0 = distance * -x1_x0 / y1_y0;
            }
            let xs = x2_x0 * d.linknum + x0,
                ys = y2_y0 * d.linknum + y0,
                xt = x2_x0 * d.linknum + x1,
                yt = y2_y0 * d.linknum + y1;
            return 'M'+xs+' '+ys+' L '+ xt +' '+yt;
        });

        node.attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; });

        link_text.attr("x", function (d) { return (d.source.x + d.target.x)/2 })
            .attr("y",function (d) { return (d.source.y + d.target.y)/2 });

        node_text.attr("x", function (d) { return d.x })
            .attr("y", function (d) { return d.y })
    }

    // 结点上色
    function color(d) {
        // colors: 3182bd: dark blue, c6dbef: light blue, fd8d3c: orange
        let fill_color;
        switch (d.type) {
            case 0:     // central node
                fill_color = "#C6DBEF";
                break;
            case 2:     // person
                fill_color = "#FD8D3C";
                break;
            case 1:     // company
                fill_color = "#3182DB";
                break;
        }
        return fill_color;
    }

    // 点击结点时淡化不相邻的点及边
    function click(d) {
        if (!d3.event.defaultPrevented) {
            var thisNode = d.id;
            var connected = root.links.filter(function(e) {
                return e.source.id === thisNode || e.target.id === thisNode
            });

            node.attr("opacity", function(d) {
                return (connected.map(d => d.source.id).indexOf(d.id) > -1 ||
                    connected.map(d => d.target.id).indexOf(d.id) > -1) ? 1 : 0.1
            })
                .attr("class","node selected");

            link.attr("opacity", function(d) {
                return (d.source.id == thisNode || d.target.id == thisNode) ? 1 : 0.1
            });

            link_text.attr("opacity", function (d) {
                return (d.source.id == thisNode || d.target.id == thisNode) ? 1 : 0.1
            })
        }
    }

    // 禁止拖拽
    function dragstop(d, i) {
        d.fixed = true;
        tick();

    }

    // 给link排序，先按source 再按target
    function sort_links(links) {
        links.sort(function(a,b) {
            if (a.source > b.source) {return 1;}
            else if (a.source < b.source) {return -1;}
            else {
                if (a.target > b.target) {return 1;}
                if (a.target < b.target) {return -1;}
                else {return 0;}
            }
        });
        return links;
    }

    // 标注边的数量
    function linkcount(links) {
        links = sort_links(links);
        for (let i = 0; i < links.length; i++) {
            if (i != 0 && links[i].source == links[i-1].source &&
                        links[i].target == links[i-1].target)
            {
                links[i].linknum = links[i-1].linknum + 1;
                links[i-1].linknum = links[i].linknum
            }
            else {
                links[i].linknum = 1;
                if(i>1 && links[i-1].linknum>1){
                    // 更新上群结点信息
                    let mid_num = (links[i-1].linknum-1)/2;
                    let ir = links[i-1].linknum;
                    for(let j = 0; j < ir; j++){
                        links[i-1-j].linknum = mid_num - j
                    }
                }
                console.log(links)
            }
        }
        if(links[links.length-1].linknum>1){
            let mid_num = (links[links.length-1].linknum-1)/2;
            let ir = links[links.length-1].linknum;
            for(let j = 0; j < ir; j++){
                links[links.length-1-j].linknum = Math.abs(mid_num - j)
            }
        }
        return links
    }

    // 对于同结点间的多条边，重新计算起止坐标
    function calcTranslationApproximate(links, targetDistance=2) {
        for (let i = 0; i < links.length; i++) {
            // 当两个结点中有多条边时
            if (links[i].linknum > 1) {
                let linknum = links[i].linknum;

                // 偶数个边时
                if (linknum % 2 === 0) {
                    console.log('偶数');
                    let center_link = linknum / 2;

                    for (let j = 0; j < links[i].linknum; j++) {
                        let gap = Math.min(center_link - j + 1, j + 1 - center_link + 1) * targetDistance;
                        let new_node = parallel_node(links[i], gap);
                        // console.log(new_node);
                        links[i + j].source.x = new_node.source.x;
                        links[i + j].source.y = new_node.source.y;
                        links[i + j].target.x = new_node.target.x;
                        links[i + j].target.y = new_node.target.y;
                    }
                    i = i + links[i].linknum - 1;
                }
                // 奇数条边时
                else {
                    console.log("奇数");
                    let center_link = Math.ceil(linknum / 2);

                    for (let j = 0; j < links[i].linknum; j++) {
                        let gap = Math.abs(center_link - j + 1) * targetDistance;
                        let new_node = parallel_node(links[i], gap);
                        links[i + j].source.x = new_node.source.x;
                        links[i + j].source.y = new_node.source.y;
                        links[i + j].target.x = new_node.target.x;
                        links[i + j].target.y = new_node.target.y;
                    }
                    i = i + links[i].linknum - 1;
                }
            }
        }
        console.log(links);
        return links;

        function parallel_node(link, distance) {
            let x0 = link.source.x,
                y0 = link.source.y,
                x1 = link.target.x,
                y1 = link.target.y,
                x1_x0 = x1 - x0,
                y1_y0 = y1 - y0,
                x2_x0, y2_y0;
            console.log(link);
            if (y1_y0 === 0 || Math.abs(x1_x0 / y1_y0) > 1) {
                y2_y0 = -distance;
                x2_x0 = distance * y1_y0 / x1_x0;
            } else {
                x2_x0 = distance;
                y2_y0 = distance * -x1_x0 / y1_y0;
            }

            return {
                "source": {"x": x2_x0 + x0, "y": y2_y0 + y0},
                "target": {"x": x2_x0 + x1, "y": y2_y0 + y1}
            }

        }
    }

</script>