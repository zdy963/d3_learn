<!DOCTYPE html>
<meta charset="utf-8">
<title>Force-Directed Graph</title>
<style>

    .node {
        cursor: pointer;
        stroke: #3182bd;
        stroke-width: 1.5px;
    }

    .link {
        fill: none;
        stroke: #9ecae1;
        stroke-width: 1.5px;
    }

    .node_text {
        font-size: 12px;
        font-family: SimSun;
        fill: white;
        font-weight: 800;
    }

    .link_text {
        font-size: 12px;
        font-family: SimSun;
        font-weight: 900;
        fill: black;
    }

    .selected{
        -webkit-transition:border linear .2s,-webkit-box-shadow linear .5s;
        border-color:rgba(141,39,142,.75);
        -webkit-box-shadow:0 0 18px rgba(111,1,32,3);
    }

</style>
<body>
<script src="//d3js.org/d3.v3.min.js"></script>
<script src="//code.jquery.com/jquery-3.3.1.slim.min.js"></script>
<script>

    $(document).on("click",function (d) {
        if(d.target.nodeName == "svg"){
            $(".node, .link, .node_text, .link_text, g")
                .attr("opacity",1)
                .removeClass("selected");
        }
    });

    var width = 960,
        height = 800,
        radius = 30,
        parallelDistance = 12,
        root;

    var force = d3.layout.force()
        .size([width, height])
        .on("tick", tick);

    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);

    var link = svg.selectAll(".link"),
        node = svg.selectAll(".node"),
        node_text = svg.selectAll(".node_text"),
        link_text = svg.selectAll(".link_text");

    d3.json("test.json", function(error, json) {
        if (error) throw error;
        root = json;

        update();
    });

    function update() {
        var nodes = root.nodes,
            links = root.links;

        links = linkcount(links);
        console.log(links);

        // 启动force layout
        force
            .nodes(nodes)
            .links(links)
            .linkDistance(200)
            .charge(-1500)
            .start();

        // 自定义拖拽函数
        var node_drag = d3.behavior.drag()
            .on("dragstart", dragstart)
            .on("drag", dragmove)
            .on("dragend", dragend);

        function dragstart(d, i) {
            force.stop() // stops the force auto positioning before you start dragging
        }
        function dragmove(d, i) {
            d.px += d3.event.dx;
            d.py += d3.event.dy;
            d.x += d3.event.dx;
            d.y += d3.event.dy;
            tick(); // this is the key to make it work together with updating both px,py,x,y on d !
        }
        function dragend(d, i) {
            d.fixed = true; // of course set the node to fixed so the force doesn't include the node in its auto positioning stuff
            tick();
            // force.resume();
        }


        // 链
        link = link.data(links);
        link.exit().remove();
        link.enter()
            .append("path")
            .attr("class", "link")
            .attr("marker-end",function(d,i){
                var arrowMarker = svg.append("marker")
                    .attr("id","arrow"+i)
                    .attr("markerUnits","userSpaceOnUse")
                    .attr("markerWidth","16")
                    .attr("markerHeight","15")
                    .attr("viewBox","0 0 10 10")
                    .attr("refX", radius)
                    .attr("refY",6)
                    .attr("orient","auto")
                    .append("svg:path")
                    .attr("d","M2,2 L10,6 L2,10 L6,6 L2,2")
                    .attr("fill",function(){
                        return d.lineColor = "" ? lineColor:d.lineColor;
                    });

                return "url(#arrow" + i + ")";
            });


        // 在链上写结点间的关系
        link_text = link_text.data(links);
        link_text.exit().remove();
        link_text.enter()
            .append("svg:g")
            .attr("fill-opacity",1);
        // 增加文本
        link_text.append("svg:text")
            .attr("class", "link_text")
            // .attr("y", ".31em")
            .attr("text-anchor", "middle")
            .attr("pointer-events", "none")
            .attr("dominant-baseline", "middle")
            .text(function(d){ return d.relationship });
        // 增加背景白块
        link_text.insert('rect', 'text')
            .attr('width', function(d){ return d.relationship.length*12 })
            .attr('height', function(d){ return 12 })
            .attr("y", "-.5em")
            .attr('x', function (d) { return -d.relationship.length*12/2 })
            .style('fill', '#FFFFFF');


        // 结点
        node = node.data(nodes, function(d) { return d.id }).style("fill", color);
        node.exit().remove();
        node.enter()
            .append("circle")
            .attr("class", "node")
            // .attr("class", "rect")
            .attr("cx", function(d) { return d.x; })    // cx define the x-axis of a center point
            .attr("cy", function(d) { return d.y; })    // cy define the y-axis ..
            .attr("r", radius)   // define the radius
            .style("fill", color)
            .on("click", click)
            .call(node_drag);


        // 在结点上写名字
        node_text = node_text.data(nodes);
        node_text.exit().remove();
        node_text.enter()
            .append("text")
            .attr("class", "node_text")
            .attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; })
            .attr("text-anchor", "middle")  // 使文本在元素上居中而非左对齐
            .attr("dominant-baseline", "middle")
            .attr("pointer-events", "none")
            .text(function (d) {
                return d.name;
            });
    }

    function multiLinks(d) {
        if(d.linknum === 0){
            d.minRadius = radius;
            // 保存起止坐标，用于改变文字方向
            d.x_start = d.source.x;
            d.y_start = d.source.y;
            d.x_end = d.target.x;
            d.y_end = d.target.y;
            return 'M' + d.source.x + ' ' + d.source.y
                    + ' L '+ d.target.x +' '+d.target.y;
        }
        else {
            // x0,y0为起点坐标，x1,y1为终点坐标，x2,y2为所求点坐标
            let x0 = d.source.x,
                y0 = d.source.y,
                x1 = d.target.x,
                y1 = d.target.y,
                x1_x0 = x1 - x0,
                y1_y0 = y1 - y0,
                x2_x0, y2_y0;

            // 更新收尾坐标，减去半径
            d.minRadius = Math.sqrt(radius*radius - parallelDistance*parallelDistance);

            if (y1_y0 === 0) {
                x2_x0 = 0;
                y2_y0 = parallelDistance;
            } else {
                let angle = Math.atan((x1_x0) / (y1_y0));
                x2_x0 = -parallelDistance * Math.cos(angle);
                y2_y0 = parallelDistance * Math.sin(angle);
            }
            // 计算平行线起止点坐标
            let xs = x2_x0 * d.linknum + x0,
                ys = y2_y0 * d.linknum + y0,
                xt = x2_x0 * d.linknum + x1,
                yt = y2_y0 * d.linknum + y1;

            // 保存起止坐标，用于改变文字方向
            d.x_start = xs;
            d.y_start = ys;
            d.x_end = xt;
            d.y_end = yt;

            return 'M'+xs+' '+ys+' L '+ xt +' '+yt;
        }
    }

    // 使结点位置可动的关键代码
    function tick() {
        // 允许两点间多条连线
        link.attr("d", function(d){ return multiLinks(d) });
        node.attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; });

        link_text
            .attr("transform", function (d) {   // 方向转至与连线相同
                return "translate(" + (d.x_start + d.x_end)/2 + "," + (d.y_start + d.y_end)/2 + ")" // 移动文字至连线中间
                    + " rotate(" + Math.atan((d.y_end - d.y_start) / (d.x_end - d.x_start)) * 180 / Math.PI + ")";  // 旋转文字与连线方向一致
            });

        node_text.attr("x", function (d) { return d.x })
            .attr("y", function (d) { return d.y })
    }

    // 结点上色
    function color(d) {
        // colors: 3182bd: dark blue, c6dbef: light blue, fd8d3c: orange
        let fill_color;
        switch (d.type) {
            case 0:     // central node
                fill_color = "#C6DBEF";
                break;
            case 2:     // person
                fill_color = "#FD8D3C";
                break;
            case 1:     // company
                fill_color = "#3182DB";
                break;
        }
        return fill_color;
    }

    // 点击结点时淡化不相邻的点及边
    function click(d) {
        if (!d3.event.defaultPrevented) {
            var thisNode = d.id;
            var connected = root.links.filter(function(e) {
                return e.source.id === thisNode || e.target.id === thisNode
            });

            node.attr("opacity", function(d) {
                return (connected.map(d => d.source.id).indexOf(d.id) > -1 ||
                    connected.map(d => d.target.id).indexOf(d.id) > -1) ? 1 : 0.1
            })
                .attr("class","node selected");

            link.attr("opacity", function(d) {
                return (d.source.id == thisNode || d.target.id == thisNode) ? 1 : 0.1
            });

            link_text.attr("opacity", function (d) {
                return (d.source.id == thisNode || d.target.id == thisNode) ? 1 : 0.1
            })
        }
    }

    // 给link排序，先按source 再按target
    function sort_links(links) {
        links.sort(function(a,b) {
            if (a.source > b.source) {return 1;}
            else if (a.source < b.source) {return -1;}
            else {
                if (a.target > b.target) {return 1;}
                if (a.target < b.target) {return -1;}
                else {return 0;}
            }
        });
        return links;
    }

    // 标注边的数量
    function linkcount(links) {
        links = sort_links(links);
        for (let i = 0; i < links.length; i++) {
            if (i != 0 && links[i].source == links[i-1].source &&
                        links[i].target == links[i-1].target)
            {
                links[i].linknum = links[i-1].linknum + 1;
            }
            else {
                links[i].linknum = 0;
                if(i > 1 && links[i-1].linknum > 0){
                    // 更新上群结点信息
                    let mid_num = (links[i-1].linknum)/2;
                    let ir = links[i-1].linknum + 1;
                    for(let j = 0; j < ir; j++){
                        links[i-1-j].linknum = mid_num - j
                    }
                }
            }
        }
        if(links[links.length-1].linknum>1){
            let mid_num = (links[links.length-1].linknum-1)/2;
            let ir = links[links.length-1].linknum;
            for(let j = 0; j < ir; j++){
                links[links.length-1-j].linknum = Math.abs(mid_num - j)
            }
        }
        return links
    }
</script>